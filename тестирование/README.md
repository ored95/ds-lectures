# Тестирование

## Общая теория тестирования

Тестирование – проверка соответствия реальных и ожидаемых результатов поведения программы, проводимая на конечном наборе
тестов, выбранном определённым образом.

Цель тестирования — проверка соответствия ПО предъявляемым требованиям, обеспечение уверенности в качестве ПО, поиск
очевидных ошибок в программном обеспечении, которые должны быть выявлены до того, как их обнаружат пользователи
программы.

### Принципы тестирования

1. Тестирование снижает вероятность наличия дефектов, но не гарантирует их отсутствие.
1. Полное тестирование с использованием всех входных комбинаций данных, результатов и предусловий физически
   невыполнимо (исключение — тривиальные случаи).
1. Раннее тестирование (Early testing) – следует начинать тестирование на ранних стадиях жизненного цикла разработки ПО,
   чтобы найти дефекты как можно раньше.
1. Скопление дефектов (Defects clustering) – большая часть дефектов находится в ограниченном количестве модулей, обычно
   в модулях, реализующих бизнес логику приложения.
1. Парадокс пестицида (Pesticide paradox) – если повторять те же тестовые сценарии снова и снова, в какой-то момент этот
   набор тестов перестанет выявлять новые дефекты.
1. Тестирование зависит от контекста (Testing is context depending) – тестирование проводится по-разному в зависимости
   от контекста. Например, программное обеспечение, в котором критически важна безопасность, тестируется иначе, чем
   новостной портал.
1. Заблуждение об отсутствии ошибок (Absence-of-errors fallacy) – отсутствие найденных дефектов при тестировании не
   всегда означает готовность продукта к релизу. Система должна быть удобна пользователю в использовании и удовлетворять
   его ожиданиям и потребностям.

### Градация серьезности багов

* Блокирующий (Blocker) – блокирующая ошибка, приводящая приложение в нерабочее состояние, в результате которого
  дальнейшая работа с тестируемой системой или ее ключевыми функциями становится невозможна для пользователя. Может быть
  только на prod.
* Критический (Critical) – критическая ошибка, неправильно работающая ключевая бизнес-логика, дыра в системе
  безопасности, проблема, приведшая к временному падению сервера или приводящая в нерабочее состояние некоторую часть
  системы, то есть не работает важная часть одной какой-либо функции, либо не работает значительная часть, но имеется
  workaround (обходной путь/другие входные точки), позволяющий продолжить работу.
* Значительный (Major) – не работает важная часть одной какой-либо функции/бизнес-логики, но при выполнении
  специфических условий, либо есть workaround, позволяющий продолжить работу, либо не работает не очень значительная
  часть какой-либо функциональности. Также относится к дефектам с высокими visibility – обычно не сильно влияющие на
  функциональность дефекты дизайна, которые, однако, сразу бросаются в глаза.
* Незначительный (Minor) – часто ошибки GUI, которые не влияют на функциональность, но портят usability или внешний вид.
  Также незначительные функциональные дефекты, либо которые воспроизводятся на определенном устройстве.
* Тривиальный (Trivial) – почти всегда дефекты на GUI — опечатки в тексте, несоответствие шрифта и оттенка и т.п., либо
  плохо воспроизводимая ошибка, не касающаяся бизнес-логики, проблема сторонних библиотек или сервисов, проблема, не
  оказывающая никакого влияния на общее качество продукта.

### Виды тестирования

![testing_pyramid](images/testing_pyramid.png)

* Unit-тесты – проверка отдельного класса программы.
* Сервисные тесты (Component Tests) – проверка, что изолированная система работает корректно (т.е. все внешние вызовы
  закрыты заглушками).
* Интеграционные тесты (Integration Tests) – тестирование контура с реальными запросами и ответами между системами.
* UI-тесты – проверка работы пользовательского интерфейса.
* Security tests – тестирование, направленное на выявление дырок в безопасности системы (как на уровне самого
  приложения, для уверенности в том, что эти изменения не внесли ошибки в областях, которые не подверглись изменениям.
  приложения, так и на уровне инфраструктуры).
* Регрессионное тестирование – тестирование уже проверенной ранее функциональности после внесения изменений в код
* Нагрузочные тесты (стресс-тесты) – тестирование поведения системы под возрастающей нагрузкой.

Методы тестирования:

* Метод белого ящика – тестирование, которое учитывает внутренние механизмы программы, обычно включает тестирование
  ветвей, маршрутов, операторов (т.е. практически всегда это unit-тесты, реже интеграционное тестирование). При
  тестировании подбирают входные параметры и определяют выходные параметры. Этот метод тестирования не может выявить
  невыполненные части спецификации.
* Метод черного ящика – также известное как тестирование, основанное на спецификации или тестирование поведения —
  техника тестирования, основанная на работе исключительно с внешними интерфейсами тестируемой системы (обычно это
  функциональное тестирование).
* Метод серого ящика – метод тестирования ПО, который предполагает комбинацию White Box и Black Box подходов. То есть,
  внутреннее устройство программы нам известно лишь частично.

### Терминология

* mock – замена реального объекта некоторой заглушкой, который мы задаем нужное нам поведение;
* spy – обертка над реальным объектом для контроля его выполнения.

## Unit тесты

Unit-тесты – важная составляющая программы, которая гарантирует работоспособность каждой части программы в отдельности.
Рассмотрим класс `UserServiceImpl` с методом createUserWithWallet создания пользователя и кошелька, обсудим что нужно
тестировать. В классе будет использовать MapStruct для маппинга `@Entity` -> DTO.

```java

@Service
@RequiredArgsConstructor
public class UserServiceImpl
        implements UserService {
    private final UserRepository userRepository;
    private final UserMapper userMapper;
    private final WalletSerice walletSerice;
     
    ...

    @Override
    @Transactional
    public UserReponse createUserWithWallet(@NotNull CreateUserRequest request) {
        User user = new User()
                .setUserName(request.getUserName())
                .setAddress(request.getAddress());
        user = userRepository.save(user);

        final Wallet wallet = walletSerice.createWalletForUser(request, user);
        user.setWallet(wallet);

        return userMapper.toModel(user);
    }
    
    ...
}
```

При написании теста на метод `createUserWithWallet` мы видим две внешние зависимости: `userMapper` и `walletService`.
`WalletService` является классом из другой доменной области, а значит его поведение некорректно тестировать в рамках
метода `createUserWithWallet`, т.к. в unit тестах нас не интересует корректность поведения других сервисов, отличных от
тестируемого, соответственного вместо `WalletService` мы вправе использовать заглушку (Mockito Mock).

С вызовом метода `userMapper.toModel(user)` все сложнее, т.к. это сгенерированный с помощью `MapStruct` маппер,
который `@Entity` преобразует в DTO через getter/setter на объектах. Заменять его моками в тестах не нужно, т.к. эта
функциональность является частью бизнес процесса класса. Раньше эти мапперы описывались в самом же классе как `private`
метод, фактически MapStruct забрал на себя необходимость писать это руками, а значит это можно рассматривать как часть
процесса выполнения основной доменной бизнес-логики.

Для того чтобы тесты было проще писать, нужно чтобы проверяемый класс отвечал только за свою функциональность и не делал
ничего больше, т.е. следовал принципу Single Responsibility. Если класс выполняем множество различных действий, то тест
получится большим и тяжело поддерживаемым, т.к. будет большим и зависить от большого числа компонентов.

### Тестирование Базы данных

### Контрактные тесты

## Нагрузочные тесты

## Тесты на UI

## Литература

1. [Understanding Your Reports: Part 3 - Key Statistics Performance Testers Need to Understand](https://www.blazemeter.com/blog/understanding-your-reports-part-3-key-statistics-performance-testers-need-understand)
2. [Несколько советов по созданию page object классов здорового человека](https://habr.com/ru/company/otus/blog/494106/)